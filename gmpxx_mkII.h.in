#ifndef GMPXX_MKII_H
#define GMPXX_MKII_H

#include <gmp.h>
#include <string>
#include <iostream>
#include <type_traits>

namespace gmpxx {

// Forward declarations
class mpz_class;
template<typename E> class mpz_expr;

// Expression template base class
template<typename E>
class mpz_expr {
public:
    const E& cast() const { return static_cast<const E&>(*this); }
    E& cast() { return static_cast<E&>(*this); }
    
    // Evaluation interface
    void eval_to(mpz_t result) const {
        cast().eval_to(result);
    }
    
    operator mpz_class() const;
};

// Binary operation expression template
template<typename L, typename R, typename Op>
class mpz_binary_expr : public mpz_expr<mpz_binary_expr<L, R, Op>> {
private:
    const L& left_;
    const R& right_;
    
public:
    mpz_binary_expr(const L& left, const R& right) : left_(left), right_(right) {}
    
    void eval_to(mpz_t result) const {
        mpz_t left_val, right_val;
        mpz_init(left_val);
        mpz_init(right_val);
        
        // Evaluate operands
        if constexpr (std::is_same_v<L, mpz_class>) {
            mpz_set(left_val, left_.get_mpz_t());
        } else {
            left_.eval_to(left_val);
        }
        
        if constexpr (std::is_same_v<R, mpz_class>) {
            mpz_set(right_val, right_.get_mpz_t());
        } else {
            right_.eval_to(right_val);
        }
        
        // Apply operation
        Op::apply(result, left_val, right_val);
        
        mpz_clear(left_val);
        mpz_clear(right_val);
    }
};

// Unary operation expression template
template<typename E, typename Op>
class mpz_unary_expr : public mpz_expr<mpz_unary_expr<E, Op>> {
private:
    const E& expr_;
    
public:
    mpz_unary_expr(const E& expr) : expr_(expr) {}
    
    void eval_to(mpz_t result) const {
        if constexpr (std::is_same_v<E, mpz_class>) {
            Op::apply(result, expr_.get_mpz_t());
        } else {
            mpz_t temp;
            mpz_init(temp);
            expr_.eval_to(temp);
            Op::apply(result, temp);
            mpz_clear(temp);
        }
    }
};

// Operation functors
struct add_op {
    static void apply(mpz_t result, const mpz_t left, const mpz_t right) {
        mpz_add(result, left, right);
    }
};

struct sub_op {
    static void apply(mpz_t result, const mpz_t left, const mpz_t right) {
        mpz_sub(result, left, right);
    }
};

struct mul_op {
    static void apply(mpz_t result, const mpz_t left, const mpz_t right) {
        mpz_mul(result, left, right);
    }
};

struct div_op {
    static void apply(mpz_t result, const mpz_t left, const mpz_t right) {
        mpz_tdiv_q(result, left, right);
    }
};

struct mod_op {
    static void apply(mpz_t result, const mpz_t left, const mpz_t right) {
        mpz_tdiv_r(result, left, right);
    }
};

struct neg_op {
    static void apply(mpz_t result, const mpz_t operand) {
        mpz_neg(result, operand);
    }
};

struct abs_op {
    static void apply(mpz_t result, const mpz_t operand) {
        mpz_abs(result, operand);
    }
};

// Main multiprecision integer class
class mpz_class {
private:
    mpz_t mp_;
    
public:
    // Constructors
    mpz_class() { mpz_init(mp_); }
    
    mpz_class(long val) { 
        mpz_init(mp_);
        mpz_set_si(mp_, val);
    }
    
    mpz_class(unsigned long val) {
        mpz_init(mp_);
        mpz_set_ui(mp_, val);
    }
    
    mpz_class(const std::string& str, int base = 10) {
        mpz_init(mp_);
        mpz_set_str(mp_, str.c_str(), base);
    }
    
    mpz_class(const char* str, int base = 10) {
        mpz_init(mp_);
        mpz_set_str(mp_, str, base);
    }
    
    // Copy constructor
    mpz_class(const mpz_class& other) {
        mpz_init(mp_);
        mpz_set(mp_, other.mp_);
    }
    
    // Expression template constructor
    template<typename E>
    mpz_class(const mpz_expr<E>& expr) {
        mpz_init(mp_);
        expr.eval_to(mp_);
    }
    
    // Destructor
    ~mpz_class() { mpz_clear(mp_); }
    
    // Assignment operators
    mpz_class& operator=(const mpz_class& other) {
        if (this != &other) {
            mpz_set(mp_, other.mp_);
        }
        return *this;
    }
    
    template<typename E>
    mpz_class& operator=(const mpz_expr<E>& expr) {
        expr.eval_to(mp_);
        return *this;
    }
    
    mpz_class& operator=(long val) {
        mpz_set_si(mp_, val);
        return *this;
    }
    
    mpz_class& operator=(unsigned long val) {
        mpz_set_ui(mp_, val);
        return *this;
    }
    
    mpz_class& operator=(const std::string& str) {
        mpz_set_str(mp_, str.c_str(), 10);
        return *this;
    }
    
    // Compound assignment operators
    template<typename E>
    mpz_class& operator+=(const mpz_expr<E>& expr) {
        mpz_t temp;
        mpz_init(temp);
        expr.eval_to(temp);
        mpz_add(mp_, mp_, temp);
        mpz_clear(temp);
        return *this;
    }
    
    mpz_class& operator+=(const mpz_class& other) {
        mpz_add(mp_, mp_, other.mp_);
        return *this;
    }
    
    template<typename E>
    mpz_class& operator-=(const mpz_expr<E>& expr) {
        mpz_t temp;
        mpz_init(temp);
        expr.eval_to(temp);
        mpz_sub(mp_, mp_, temp);
        mpz_clear(temp);
        return *this;
    }
    
    mpz_class& operator-=(const mpz_class& other) {
        mpz_sub(mp_, mp_, other.mp_);
        return *this;
    }
    
    template<typename E>
    mpz_class& operator*=(const mpz_expr<E>& expr) {
        mpz_t temp;
        mpz_init(temp);
        expr.eval_to(temp);
        mpz_mul(mp_, mp_, temp);
        mpz_clear(temp);
        return *this;
    }
    
    mpz_class& operator*=(const mpz_class& other) {
        mpz_mul(mp_, mp_, other.mp_);
        return *this;
    }
    
    template<typename E>
    mpz_class& operator/=(const mpz_expr<E>& expr) {
        mpz_t temp;
        mpz_init(temp);
        expr.eval_to(temp);
        mpz_tdiv_q(mp_, mp_, temp);
        mpz_clear(temp);
        return *this;
    }
    
    mpz_class& operator/=(const mpz_class& other) {
        mpz_tdiv_q(mp_, mp_, other.mp_);
        return *this;
    }
    
    // Access to underlying GMP type
    mpz_t& get_mpz_t() { return mp_; }
    const mpz_t& get_mpz_t() const { return mp_; }
    
    // Conversion functions
    long get_si() const { return mpz_get_si(mp_); }
    unsigned long get_ui() const { return mpz_get_ui(mp_); }
    double get_d() const { return mpz_get_d(mp_); }
    
    std::string get_str(int base = 10) const {
        char* str = mpz_get_str(nullptr, base, mp_);
        std::string result(str);
        free(str);
        return result;
    }
    
    // Utility functions
    size_t size() const { return mpz_size(mp_); }
    int sgn() const { return mpz_sgn(mp_); }
    
    // Comparison operators
    bool operator==(const mpz_class& other) const {
        return mpz_cmp(mp_, other.mp_) == 0;
    }
    
    bool operator!=(const mpz_class& other) const {
        return mpz_cmp(mp_, other.mp_) != 0;
    }
    
    bool operator<(const mpz_class& other) const {
        return mpz_cmp(mp_, other.mp_) < 0;
    }
    
    bool operator<=(const mpz_class& other) const {
        return mpz_cmp(mp_, other.mp_) <= 0;
    }
    
    bool operator>(const mpz_class& other) const {
        return mpz_cmp(mp_, other.mp_) > 0;
    }
    
    bool operator>=(const mpz_class& other) const {
        return mpz_cmp(mp_, other.mp_) >= 0;
    }
};

// Implementation of conversion from expression to mpz_class
template<typename E>
mpz_expr<E>::operator mpz_class() const {
    return mpz_class(*this);
}

// Binary operators
template<typename L, typename R>
auto operator+(const mpz_expr<L>& left, const mpz_expr<R>& right) {
    return mpz_binary_expr<L, R, add_op>(left.cast(), right.cast());
}

template<typename E>
auto operator+(const mpz_expr<E>& left, const mpz_class& right) {
    return mpz_binary_expr<E, mpz_class, add_op>(left.cast(), right);
}

template<typename E>
auto operator+(const mpz_class& left, const mpz_expr<E>& right) {
    return mpz_binary_expr<mpz_class, E, add_op>(left, right.cast());
}

auto operator+(const mpz_class& left, const mpz_class& right) {
    return mpz_binary_expr<mpz_class, mpz_class, add_op>(left, right);
}

template<typename L, typename R>
auto operator-(const mpz_expr<L>& left, const mpz_expr<R>& right) {
    return mpz_binary_expr<L, R, sub_op>(left.cast(), right.cast());
}

template<typename E>
auto operator-(const mpz_expr<E>& left, const mpz_class& right) {
    return mpz_binary_expr<E, mpz_class, sub_op>(left.cast(), right);
}

template<typename E>
auto operator-(const mpz_class& left, const mpz_expr<E>& right) {
    return mpz_binary_expr<mpz_class, E, sub_op>(left, right.cast());
}

auto operator-(const mpz_class& left, const mpz_class& right) {
    return mpz_binary_expr<mpz_class, mpz_class, sub_op>(left, right);
}

template<typename L, typename R>
auto operator*(const mpz_expr<L>& left, const mpz_expr<R>& right) {
    return mpz_binary_expr<L, R, mul_op>(left.cast(), right.cast());
}

template<typename E>
auto operator*(const mpz_expr<E>& left, const mpz_class& right) {
    return mpz_binary_expr<E, mpz_class, mul_op>(left.cast(), right);
}

template<typename E>
auto operator*(const mpz_class& left, const mpz_expr<E>& right) {
    return mpz_binary_expr<mpz_class, E, mul_op>(left, right.cast());
}

auto operator*(const mpz_class& left, const mpz_class& right) {
    return mpz_binary_expr<mpz_class, mpz_class, mul_op>(left, right);
}

template<typename L, typename R>
auto operator/(const mpz_expr<L>& left, const mpz_expr<R>& right) {
    return mpz_binary_expr<L, R, div_op>(left.cast(), right.cast());
}

template<typename E>
auto operator/(const mpz_expr<E>& left, const mpz_class& right) {
    return mpz_binary_expr<E, mpz_class, div_op>(left.cast(), right);
}

template<typename E>
auto operator/(const mpz_class& left, const mpz_expr<E>& right) {
    return mpz_binary_expr<mpz_class, E, div_op>(left, right.cast());
}

auto operator/(const mpz_class& left, const mpz_class& right) {
    return mpz_binary_expr<mpz_class, mpz_class, div_op>(left, right);
}

template<typename L, typename R>
auto operator%(const mpz_expr<L>& left, const mpz_expr<R>& right) {
    return mpz_binary_expr<L, R, mod_op>(left.cast(), right.cast());
}

template<typename E>
auto operator%(const mpz_expr<E>& left, const mpz_class& right) {
    return mpz_binary_expr<E, mpz_class, mod_op>(left.cast(), right);
}

template<typename E>
auto operator%(const mpz_class& left, const mpz_expr<E>& right) {
    return mpz_binary_expr<mpz_class, E, mod_op>(left, right.cast());
}

auto operator%(const mpz_class& left, const mpz_class& right) {
    return mpz_binary_expr<mpz_class, mpz_class, mod_op>(left, right);
}

// Unary operators
template<typename E>
auto operator-(const mpz_expr<E>& expr) {
    return mpz_unary_expr<E, neg_op>(expr.cast());
}

auto operator-(const mpz_class& val) {
    return mpz_unary_expr<mpz_class, neg_op>(val);
}

// Mathematical functions
template<typename E>
auto abs(const mpz_expr<E>& expr) {
    return mpz_unary_expr<E, abs_op>(expr.cast());
}

auto abs(const mpz_class& val) {
    return mpz_unary_expr<mpz_class, abs_op>(val);
}

// Power function
mpz_class pow(const mpz_class& base, unsigned long exp);
mpz_class powm(const mpz_class& base, const mpz_class& exp, const mpz_class& mod);

// GCD and LCM
mpz_class gcd(const mpz_class& a, const mpz_class& b);
mpz_class lcm(const mpz_class& a, const mpz_class& b);

// Square root
mpz_class sqrt(const mpz_class& val);

// Stream operators
std::ostream& operator<<(std::ostream& os, const mpz_class& val);
std::istream& operator>>(std::istream& is, mpz_class& val);

} // namespace gmpxx

#endif // GMPXX_MKII_H
